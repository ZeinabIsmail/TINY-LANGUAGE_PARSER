# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'mainWindow.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import os
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QIcon
from PyQt5.QtWidgets import QApplication, QWidget, QPushButton, QGraphicsSimpleTextItem
from PyQt5.Qt import QFileInfo
from secondwindow import SecondWindow
from image import Ui_Form1
from parserfinal import *
from networkx.drawing.nx_pydot import graphviz_layout
import networkx as nx
import matplotlib.pyplot as plt
from graphviz import Graph
import pygraphviz as pgv

import json
import pickle
from lex import *


class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.resize(1056, 843)
        MainWindow.setStyleSheet("\n"
                                 "background-color:rgb(205, 255, 229)")
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.lineEdit_filedir = QtWidgets.QLineEdit(self.centralwidget)
        self.lineEdit_filedir.setGeometry(QtCore.QRect(190, 30, 701, 51))
        self.lineEdit_filedir.setStyleSheet("border-color:rgb(81, 147, 97);\n"
                                            "border-style :solid;\n"
                                            "border-width:2px;\n"
                                            "font-size: 25px;\n"
                                            "color: rgb(31, 74, 19);\n"
                                            "border-radius: 5px;")
        self.lineEdit_filedir.setObjectName("lineEdit_filedir")
        self.pushButton_browse = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_browse.clicked.connect(self.browseFiles)
        self.pushButton_browse.setGeometry(QtCore.QRect(900, 30, 141, 51))
        self.pushButton_browse.setStyleSheet("border-color:rgb(81, 147, 97);\n"
                                             "border-style :inset;\n"
                                             "border-width: 3px;\n"
                                             "font-size: 25px;\n"
                                             "color: rgb(31, 74, 19)")
        self.pushButton_browse.setObjectName("pushButton_browse")
        self.label = QtWidgets.QLabel(self.centralwidget)
        self.label.setGeometry(QtCore.QRect(40, 30, 141, 51))
        self.label.setStyleSheet("border-color:rgb(81, 147, 97);\n"
                                 "border-style :solid;\n"
                                 "border-width:2px;\n"
                                 "font-size: 25px;\n"
                                 "color: rgb(31, 74, 19);\n"
                                 "border-radius: 5px;")
        self.label.setObjectName("label")
        self.pushButton = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton.clicked.connect(self.scanner)
        self.pushButton.setGeometry(QtCore.QRect(270, 90, 171, 71))
        self.pushButton.setStyleSheet("border-color:rgb(81, 147, 97);\n"
                                      "border-style :inset;\n"
                                      "border-width: 3px;\n"
                                      "font-size: 25px;\n"
                                      "color: rgb(31, 74, 19)")
        self.pushButton.setObjectName("pushButton")
        self.pushButton_2 = QtWidgets.QPushButton(self.centralwidget)
        self.pushButton_2.clicked.connect(self.new_file)
        self.pushButton_2.setGeometry(QtCore.QRect(510, 90, 181, 71))
        self.pushButton_2.setStyleSheet("border-color:rgb(81, 147, 97);\n"
                                        "border-style :inset;\n"
                                        "border-width: 3px;\n"
                                        "font-size: 25px;\n"
                                        "color: rgb(31, 74, 19)")
        self.pushButton_2.setObjectName("pushButton_2")
        self.label1 = QtWidgets.QLabel(self.centralwidget)
        self.label1.setGeometry(QtCore.QRect(15, 191, 1031, 611))
        self.label1.setStyleSheet("border-color:rgb(81, 147, 97);\n"
                                  "border-style :inset;\n"
                                  "border-width: 3px;\n"
                                  "font-size: 25px;\n"
                                  "color: rgb(31, 74, 19)")
        self.label1.setObjectName("graphicsView")
        MainWindow.setCentralWidget(self.centralwidget)

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)

    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Compiler"))
        self.pushButton_browse.setText(_translate("MainWindow", "Browse"))
        self.label.setText(_translate("MainWindow", "Choose file "))
        self.pushButton.setText(_translate("MainWindow", "Output"))
        self.pushButton_2.setText(_translate("MainWindow", "New File"))

    def browseFiles(self):
        options = QtWidgets.QFileDialog.Options()
        options |= QtWidgets.QFileDialog.DontUseNativeDialog
        fileName, _ = QtWidgets.QFileDialog.getOpenFileName(None, "Browse Files", "",
                                                            "All Files (*);;Python Files (*.py)", options=options)
        if fileName:
            print(fileName)
        self.lineEdit_filedir.setText(fileName)

    def nonempty_lines(self):
        file = open(self.lineEdit_filedir.text(), "r")
        line_count = 0
        for line in file:
            if line != "\n":
                line_count += 1
        file.close()
        return line_count
        pass

    def get_input_from_user(self, input):
        final_output_token = []
        final_output_value = []
        result = []
        lexer = Lexer(input)
        token = lexer.getToken()
        while token.kind != TokenType.EOF:
            final_output_token.append(token.text.lower())
            convert_to_str = token.kind
            convert2 = convert_to_str.name
            token = lexer.getToken()
            final_output_value.append(convert2.lower())
        result.append(final_output_token)
        result.append(final_output_value)
        return result

    def read(self, i, label):
        self.graph.add_node(i, label=label, shape='rectangle')
        ret_list = []
        ret_list.append(i)
        temp = self.graph.get_node(i)
        ret_list.append(temp)
        return ret_list

    def write(self, i, edges1, edges2, edges, nodes, visited):
        self.graph.add_node(i, label='write', shape='rectangle')
        visited.append(i)
        ret_list = []
        ret_list.append(i)
        temp = self.graph.get_node(i)
        ret_list.append(temp)
        child = edges2[edges1.index(i)]
        self.graph.add_node(child, label=nodes[child][0]+'\n'+nodes[child][1], shape='oval')
        temp_child = self.graph.get_node(child)
        visited.append(child)
        self.graph.add_edge(temp, temp_child)
        edges.remove((i, child))
        return ret_list

    def assign(self, i, label, edges1, edges2, edges, nodes, visited):
        self.graph.add_node(i, label=label, shape='rectangle')
        ret_list = []
        visited.append(i)
        ret_list.append(i)
        temp = self.graph.get_node(i)
        ret_list.append(temp)
        children = []
        for j in range(0, len(edges1)):
            if edges1[j] == i:
                children.append(edges2[j])
        if nodes[children[0]][0] == 'const':
            self.graph.add_node(children[0], label=nodes[children[0]][0]+'\n'+nodes[children[0]][1], shape='oval')
            visited.append(children[0])
            temp_child = self.graph.get_node(children[0])
            self.graph.add_edge(temp, temp_child)
            edges.remove((i, children[0]))
        else:
            temp_childe = self.op_stmt(children[0], nodes[children[0]][0]+'\n'+nodes[children[0]][1], edges1, edges2, edges, nodes, visited)
            self.graph.add_edge(temp, temp_childe[1])
            edges.remove((i, temp_childe[0]))
        return ret_list

    def op_stmt(self, i, label, edges1, edges2, edges, nodes, visited):
        self.graph.add_node(i, label=label, shape='oval')
        visited.append(i)
        ret_list=[]
        ret_list.append(i)
        temp = self.graph.get_node(i)
        ret_list.append(temp)
        children = []
        for j in range(0, len(edges1)):
            if edges1[j] == i:
                children.append(edges2[j])
        for child in children:
            if nodes[child][0] == 'op':
                listt = self.op_stmt(child, nodes[child][0] + '\n' + nodes[child][1], edges1, edges2, edges, nodes, visited)
            self.graph.add_node(child, label=nodes[child][0] + '\n' + nodes[child][1], shape='oval')
            visited.append(child)
            temp_child = self.graph.get_node(child)
            self.graph.add_edge(temp, temp_child)
            edges.remove((i, child))
        return ret_list

    def repeat_stmt(self, i, edges1, edges2, edges, nodes, visited):
        ret_list = []
        self.graph.add_node(i, label='repeat', shape='rectangle')
        visited.append(i)
        ret_list.append(i)
        temp = self.graph.get_node(i)
        ret_list.append(temp)
        children = []
        for j in range(0, len(edges1)):
            if edges1[j] == i:
                children.append(edges2[j])
        if nodes[children[0]][0] == 'op':
            op_temp = self.op_stmt(children[0], nodes[children[0]][0]+'\n'+nodes[children[0]][1], edges1, edges2, edges,
                                   nodes, visited)
            if nodes[children[1]][0] == 'assign':
                temp1 = self.assign(children[1], nodes[children[1]][0]+'\n'+nodes[children[1]][1], edges1, edges2, edges, nodes, visited)
            elif nodes[children[1]][0] == 'read':
                temp1 = self.read(children[1], nodes[children[1]][0]+'\n'+nodes[children[1]][1])
            elif nodes[children[1]][0] == 'write':
                temp1 = self.write(children[1], edges1, edges2, edges, nodes, visited)
        else:
            op_temp = self.op_stmt(children[1], nodes[children[1]][0] + '\n' + nodes[children[1]][1], edges1, edges2, edges,
                             nodes, visited)
            if nodes[children[0]][0] == 'assign':
                temp1 = self.assign(children[0], nodes[children[0]][0] + '\n' + nodes[children[0]][1], edges1, edges2, edges, nodes, visited)
            elif nodes[children[0]][0] == 'read':
                temp1 = self.read(children[0], nodes[children[0]][0] + '\n' + nodes[children[0]][1])
            elif nodes[children[0]][0] == 'write':
                temp1 = self.write(children[0], edges1, edges2, edges, nodes, visited)
        self.graph.add_edge(temp, op_temp[1])
        edges.remove((i, op_temp[0]))
        self.graph.add_edge(temp, temp1[1])
        edges.remove((i, temp1[0]))
        return ret_list

    def if_stmt(self, i, edges1, edges2, edges, nodes, visited):
        self.graph.add_node(i, label='if', shape='rectangle')
        visited.append(i)
        tempno = i
        temp = self.graph.get_node(i)
        children = []
        for j in range(0, len(edges1)):
            if edges1[j] == i:
                children.append(edges2[j])
        if nodes[children[0]][0] == 'op':
            temp1 = self.op_stmt(children[0], nodes[children[0]][0]+'\n'+nodes[children[0]][1], edges1, edges2, edges, nodes, visited)
            if nodes[children[1]][0] == 'assign':
                temp2 = self.assign(children[1], nodes[children[1]][0]+'\n'+nodes[children[1]][1], edges1, edges2, edges, nodes, visited)
            elif nodes[children[1]][0] == 'read':
                temp2 = self.read(children[1], nodes[children[1]][0]+'\n'+nodes[children[1]][1])
            elif nodes[children[1]][0] == 'write':
                temp2 = self.write(children[1], edges1, edges2, edges, nodes, visited)
            else:
                temp2 = self.repeat_stmt(children[1], edges1, edges2, edges, nodes, visited)

        else:
            temp1 = self.op_stmt(children[1], nodes[children[1]][0] + '\n' + nodes[children[1]][1], edges1, edges2, edges,
                         nodes, visited)
            if nodes[children[0]][0] == 'assign':
                temp2 = self.assign(children[0], nodes[children[0]][0] + '\n' + nodes[children[0]][1], edges1, edges2,
                            edges, nodes, visited)
            elif nodes[children[0]][0] == 'read':
                temp2 = self.read(children[0], nodes[children[0]][0] + '\n' + nodes[children[0]][1])
            elif nodes[children[0]][0] == 'write':
                temp2 = self.write(children[0], edges1, edges2, edges, nodes, visited)
            else:
                temp2 = self.repeat_stmt(i, edges1, edges2, edges, nodes, visited)
        self.graph.add_edge(temp, temp1[1])
        edges.remove((i, temp1[0]))
        self.graph.add_edge(temp, temp2[1])
        edges.remove((i, temp2[0]))

    def scan(self):
        tokenlist = []
        lexlist = []
        count = 0
        file = open(self.lineEdit_filedir.text(), 'r')
        line_count = self.nonempty_lines()
        for line in range(0, line_count):
            count = count + 1
            input = file.readline()
            return_list = self.get_input_from_user(input.upper())
            tokenlist.append(return_list[0])
            lexlist.append(return_list[1])
        final_output_token1 = []
        for i in range(0, len(lexlist)):
            for j in range(0, len(lexlist[i])):
                if lexlist[i][j] == 'newline':
                    pass
                elif lexlist[i][j] == 'semicolon':
                    final_output_token1.append(';')
                elif lexlist[i][j] == 'lessthan':
                    final_output_token1.append('<')
                elif lexlist[i][j] == 'greaterthan':
                    final_output_token1.append('>')
                elif lexlist[i][j] == 'assign':
                    final_output_token1.append(':=')
                elif lexlist[i][j] == 'plus':
                    final_output_token1.append('+')
                elif lexlist[i][j] == 'minus':
                    final_output_token1.append('-')
                elif lexlist[i][j] == 'mult':
                    final_output_token1.append('*')
                elif lexlist[i][j] == 'div':
                    final_output_token1.append('/')
                elif lexlist[i][j] == 'equal':
                    final_output_token1.append('=')
                elif lexlist[i][j] == 'then':
                    final_output_token1.append('then')
                else:
                    final_output_token1.append(lexlist[i][j])
        final_output_value1 = []
        for i in range(0, len(tokenlist)):
            for j in range(0, len(tokenlist[i])):
                if tokenlist[i][j] != '\n':
                    final_output_value1.append(tokenlist[i][j])
        temp = []
        temp.append(final_output_token1)
        temp.append(final_output_value1)
        return temp

    def scanner(self):
        self.graph = pgv.AGraph(k=2, ordering='out', splines='Line', overlap='scale', constraint=False)
        tempo = self.scan()
        self.parse_code = Parser()
        self.parse_code.set_tokens_list_and_code_list(tempo[0], tempo[1])
        self.parse_code.run()
        nodes_list = self.parse_code.formate_nodes_table(tempo[1])
        edges_list = self.parse_code.edges_table
        visited = []
        node_edges1 = []
        node_edges2 = []
        for edge in edges_list:
            node_edges1.append(edge[0])
            node_edges2.append(edge[1])
        con = len(nodes_list)
        for i in range(0, con):
            if i in visited:
                pass
            else:
                stmt = nodes_list[i][0]
                if stmt == 'read':
                    visited.append(i)
                    self.read(i, nodes_list[i][0]+'\n'+nodes_list[i][1])
                elif stmt == 'write':
                    self.write(i, node_edges1, node_edges2, edges_list, nodes_list, visited)
                elif stmt == 'assign':
                    self.assign(i, nodes_list[i][0]+'\n'+nodes_list[i][1], node_edges1, node_edges2, edges_list, nodes_list, visited)
                elif stmt == 'repeat':
                    self.repeat_stmt(i,node_edges1, node_edges2, edges_list, nodes_list, visited)
                elif stmt == 'if':
                    print(stmt)
                    self.if_stmt(i, node_edges1, node_edges2, edges_list, nodes_list, visited)
                else:
                    pass
        for i in edges_list:
            self.graph.subgraph(nbunch=[i[0], i[1]], rank='same')
            self.graph.add_edge(i[0], i[1], constraint=False)
        self.graph.draw('SyntaxTree.png', prog='dot')
        self.parse_code.clear_tables()
        self.form1 = QtWidgets.QMainWindow()
        self.ui = Ui_Form1()
        self.ui.setupUi(self.form1)
        self.form1.show()

    def new_file(self):
        self.lineEdit_filedir.clear()
        self.graph.clear()
        os.remove('SyntaxTree.png')


if __name__ == "__main__":
    import sys

    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())
